# RAG, embedding i vektorske baze

U ovoj ključnoj lekciji, ulazimo u svijet **RAG (Retrieval-Augmented Generation)** tehnologije. Naučit ćemo kako napraviti pametnog chatbota koji ne odgovara samo na osnovu opšteg znanja, već može čitati, razumjeti i odgovarati na pitanja o specifičnim dokumentima koje mu vi date, kao što su PDF fajlovi. Za čuvanje znanja iz tih dokumenata koristit ćemo **ChromaDB**, popularnu open-source vektorsku bazu podataka.

## 1. Razumijevanje Osnovnih Koncepata

### 1. Šta je RAG (Retrieval-Augmented Generation)?

![6878b8fa-5e74-45a1-9a89-5aab92889126_2366x990.gif](/files/images/10_6878b8fa-5e74-45a1-9a89-5aab92889126_2366x990.gif)

- To je tehnika koja omogućava jezičkim modelima (LLM) da pristupe eksternim izvorima znanja (poput vašeg PDF dokumenta) prije nego što generišu odgovor.
- **Jednostavnim rječnikom:** Zamislite da AI polaže ispit. Bez RAG-a, on odgovara samo na osnovu onoga što zna napamet. Sa RAG-om, vi mu date "otvorenu knjigu" (vaš PDF), on prvo pronađe relevantan pasus u knjizi, a zatim na osnovu toga formuliše precizan odgovor.
- Ovo rješava problem "halucinacija" i omogućava AI-ju da odgovara na pitanja o privatnim ili novijim podacima.

### 2. Šta je ChromaDB (Vektorska Baza)?

![token.png](/files/images/10_token.png)

- To je specijalna vrsta baze podataka napravljena za AI aplikacije. Umjesto da čuva tekst, ona čuva **vektore**.
- **Šta su vektori (ili *embeddings*)?** To su numerički "otisci prsta" teksta. Tekst sa sličnim značenjem imat će slične numeričke otiske. Ovo omogućava bazi da pretražuje po **semantičkoj sličnosti (značenju)**, a ne samo po ključnim riječima.

### 3. Kako RAG proces funkcioniše:

1. **Učitavanje i "usitnjavanje" (*Chunking*):** Kada uploadujete PDF, sistem ga prvo razbije na manje, logičke dijelove teksta koji se zovu "čankovi" (*chunks*).
2. **Embedding:** Svaki čank se pretvara u vektor (numerički otisak) i sprema u ChromaDB.
3. **Upit korisnika:** Vi postavite pitanje (npr. "Koje procesore podržava ovaj laptop?").
4. **Pretraga:** Sistem pretvara vaše pitanje u vektor i pretražuje ChromaDB da pronađe čankove sa najsličnijim "otiscima prsta".
5. **Generisanje odgovora:** Najrelevantniji čankovi se, zajedno sa vašim originalnim pitanjem, šalju jezičkom modelu (npr. Gemini), koji zatim generiše konačan, kontekstualno tačan odgovor.

## 2. Kreiranje RAG Aplikacije uz pomoć AI-ja

**1. Priprema projekta:**

- Kreirajte novi folder (npr. `moj-rag-projekat`).
- Otvorite ga u Warp terminalu i kreirajte virtuelno okruženje (`uv venv`).
- **VAŽNA PREDINSTALACIJA:** ChromaDB se oslanja na C++ komponente. Da biste izbjegli greške pri instalaciji, preuzmite i instalirajte [C++ Redistributable](https://visualstudio.microsoft.com/visual-cpp-build-tools/).

**2. Generisanje koda pomoću Qwen/Gemini CLI:**

- Pokrenite AI asistenta i zadajte mu detaljan upit. Veoma je važno biti precizan.
    
    ```
    Create a Python chatbot for a RAG system with PDF files. Use Streamlit for the interface. The user should be able to upload a PDF file, which will then be processed and stored. After that, the user can ask questions about the content of that PDF. Use ChromaDB for the vector database and the Gemini API for the language model. Also, use the uv pip installer for packages.
    ```
    
- AI će sada generisati kompletnu strukturu projekta i instalirati sve potrebne biblioteke, uključujući: `langchain`, `chromadb`, `pypdf`, `streamlit`, `google-generativeai`, `sentence-transformers`, itd.

## 3. Debugging i Optimizacija – Ključni koraci

Generisani kod često neće raditi "iz prve". Ovo je normalan dio procesa i odlična prilika za učenje.

### 1. Rješavanje problema sa zavisnostima:

- **Problem:** Aplikacija se ruši jer nedostaje neki paket (npr. `torch`, `tiktoken`).
- **Rješenje:** Pažljivo pročitajte poruku o grešci i ručno instalirajte paket koji nedostaje koristeći `uv pip install [ime_paketa]`.

### 2. Optimizacija "usitnjavanja" (Chunking):

![66f6015d895effddb4773bc5_66f600a65e092abb34613a3b_Chunking-For-RAG.webp](/files/images/10_3fbe2cdf-04be-4a63-afa5-78a5311ddfd5.png)

- **Problem:** Prilikom postavljanja pitanja, dobijate netačne ili besmislene odgovore, iako znate da informacija postoji u PDF-u.
- **Uzrok:** Loša strategija "usitnjavanja". Ako su čankovi preveliki, gubi se preciznost; ako su premali, gubi se kontekst.
- **Rješenje:** Pronađite dio koda gdje se vrši podjela teksta (obično se koristi `RecursiveCharacterTextSplitter` iz LangChain-a) i podesite dva ključna parametra:
    - `chunk_size=1000`: Veličina svakog čanka u karakterima.
    - `chunk_overlap=200`: Broj karaktera koji će se preklapati između dva susjedna čanka. Ovo je izuzetno važno da se ne bi izgubio kontekst na prelazima.
- Nakon ove promjene, ponovo uploadujte PDF i testirajte. Rezultati će biti drastično bolji.

### 3. Sprječavanje duplikata u bazi podataka:

- **Problem:** Svaki put kada uploadujete isti PDF, on se ponovo obrađuje i duplira u bazi, što je neefikasno.
- **Rješenje:** Implementirati provjeru pomoću **file hash-a**. Prije obrade, izračunajte jedinstveni "otisak prsta" (hash) fajla. Provjerite da li podaci za taj hash već postoje u bazi. Ako postoje, preskočite obradu.
- Zadajte AI-ju novi zadatak:
    
    ```
    Please modify the code so it doesn't process duplicate PDF files. Before processing, it should check for the file's hash. If the data for that hash already exists, skip the processing.
    ```
    

### 4. Osiguravanje trajne baze podataka (Persistence):

- **Problem:** Baza podataka se briše svaki put kada ponovo pokrenemo aplikaciju.
- **Rješenje:** U kodu gdje se inicijalizuje ChromaDB, potrebno je navesti putanju do foldera gdje će se baza trajno čuvati.
- Zadajte AI-ju upit:
    
    ```
    Please ensure that the ChromaDB uses persistent storage so that the data is not lost between sessions. Save the database in a folder named 'vector_database'.
    ```
    

## Zaključak

Uspješno ste napravili svoju prvu RAG aplikaciju! Naučili ste kako da jezičkom modelu date "supermoć" čitanja vaših dokumenata, kako da koristite vektorske baze za efikasnu pretragu, i, što je najvažnije, kako da optimizujete i debugirate sistem za postizanje tačnih i relevantnih odgovora.