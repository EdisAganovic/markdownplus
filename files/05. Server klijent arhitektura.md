# Server klijent arhitektura

U ovoj lekciji prelazimo sa jednostavnog koncepta "jedna skripta radi sve" na razumijevanje profesionalne **klijent-server arhitekture**. Naučit ćemo zašto je ključno odvojiti našu aplikaciju (klijenta) od pozadinske logike (servera) i kako pravilno strukturirati naš kod kako bi bio održiv i skalabilan.

## 1. Problem sa našom trenutnom aplikacijom

Naš trenutni chatbot (`app.py`) direktno komunicira sa Gemini API-jem, koristeći naš lični API ključ. Ovo je u redu za učenje, ali je **katastrofalno** za stvarnu aplikaciju.

- **Glavni problem:** Ako bismo ovakvu aplikaciju dali klijentu, morali bismo mu dati i naš tajni API ključ. Time mu dajemo "ključeve od kuće" – mogao bi koristiti naš nalog, trošiti naše resurse i napraviti ogroman račun. To se nikada ne smije raditi.

## 2. Rješenje – Klijent-Server Arhitektura

Profesionalne aplikacije rade po principu razdvajanja.

1. **Klijent (Naš Chatbot):**
    - Ovo je dio aplikacije koji korisnik vidi i sa kojim komunicira (npr. naša Streamlit aplikacija).
    - Klijent **ne zna** ništa o Gemini-ju, OpenAI-ju ili bilo kojem drugom AI servisu. On ne posjeduje nikakve tajne API ključeve.
    - Njegov jedini zadatak je da pošalje korisnikov upit (prompt) na **naš server** i da prikaže odgovor koji dobije nazad.
    - Za komunikaciju sa našim serverom, klijent koristi svoju jedinstvenu autentifikaciju (npr. korisničko ime i lozinku, ili poseban API ključ koji smo mu mi dodijelili).
2. **Server (Naša Pozadinska Aplikacija):**
    - Ovo je "mozak" operacije. To je aplikacija koja radi 24/7 na nekoj mašini (npr. zakupljeni VPS - Virtual Private Server).
    - **Njegove odgovornosti su:**
        - **Upravljanje korisnicima:** Sadrži bazu podataka sa korisnicima i njihovim paketima (npr. "besplatni", "premium").
        - **Čuvanje API ključeva:** **Samo server** posjeduje tajne API ključeve za Gemini, OpenAI, Groq, itd.
        - **Kontrola troškova:** Prati koliko tokena svaki korisnik troši i ograničava ga prema njegovom paketu.
        - **Posredovanje:** Prima zahtjev od klijenta, odlučuje kojem AI provajderu će ga proslijediti (Gemini, OpenAI...), šalje zahtjev, prima odgovor i vraća ga klijentu.
        - **Caching:** Ako više korisnika postavlja isto pitanje (npr. "Šta je RAG?"), server može sačuvati odgovor i odmah ga vratiti, bez ponovnog slanja zahtjeva AI modelu, čime štedimo tokene.
        - **Sigurnost i zaštita:** Sprječava zloupotrebe, npr. ako korisnik zatraži da mu AI napiše knjigu od 300 stranica, server može presresti taj zahtjev i vratiti poruku o grešci.

**Zašto je ovo važno?** Zato što imamo **potpunu kontrolu**. Mi odlučujemo ko, kako i koliko može koristiti naš sistem, i naši tajni ključevi su sigurni.

![image.png](/files/images/05_image.png)

## 3. Primjena principa na naš kod – Arhitektura aplikacije

Isti princip razdvajanja logike trebamo primijeniti i unutar našeg koda. Umjesto da imamo jedan ogroman `app.py` fajl, trebamo ga podijeliti na logičke cjeline.

- **Problem:** Trenutno, `app.py` sadrži sve – kod za interfejs, kod za konekciju na API, logiku za chat, itd. To postaje nepregledno i teško za održavanje.
- **Rješenje: Modularizacija koda**
    - **`app.py` (Glavni fajl):** Treba da sadrži samo osnovnu logiku i da poziva funkcije iz drugih modula. Njegov zadatak je da "orkestrira" rad cijele aplikacije.
    - **`interface.py` (Modul za korisnički interfejs):** Sav kod koji se odnosi na Streamlit (kreiranje dugmića, polja za unos, ispisivanje poruka) treba da bude ovdje.
    - **`connect.py` (Modul za konekcije):** Ovdje će biti funkcije za povezivanje na različite AI provajdere. Na primjer, mogli bismo imati funkciju:
    Glavni `app.py` bi samo pozvao ovu funkciju, ne brinući se o detaljima implementacije.
        
        ```python
        def get_model_response(provider, model_name, api_key, prompt):
            # Logika za konekciju na Google, OpenAI, itd.
            # ...
            return response
        ```
        
    - **`utils.py` (Pomoćne funkcije):** Ovdje mogu ići funkcije za obradu teksta, rad sa fajlovima, itd.

**Zašto je ovo važno?**

- **Preglednost:** Lako se snalazite u kodu.
- **Održavanje:** Ako se promijeni način konekcije na Gemini, mijenjate samo `connect.py`, a ostatak aplikacije ostaje netaknut.
- **Ponovna iskoristivost:** Funkcije iz `connect.py` možete koristiti u drugim projektima.
- **Lakši rad sa AI alatima:** Manji, fokusirani fajlovi su lakši za analizu AI asistentima, što dovodi do boljih i bržih rezultata.

## Zaključak

Razmišljanje u terminima klijent-server arhitekture i modularizacija koda su fundamentalni principi profesionalnog razvoja softvera. Oni nam omogućavaju da gradimo sigurne, efikasne i održive aplikacije.